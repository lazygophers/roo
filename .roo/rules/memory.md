# 记忆库核心规则 (Memory Core Rules)

本文件定义了 **记忆库** 的结构、格式和运作规则，是所有与记忆库相关的 AI 行为的最高准则。

---

## 1. 核心原则与架构 (Core Principles & Architecture)

### 1.1 最高准则

- **记忆驱动**: 记忆库是所有工作流的核心驱动力。
- **状态强制明示**: 在每次响应前，**必须**明确标示当前记忆库的激活状态 (`[记忆库: ON]`, `[记忆库: OFF]`, `[记忆库: PAUSED]`, `[记忆库: PADDING]`)。

### 1.2 认知压缩引擎架构

采用分层与压缩相结合的记忆架构。

#### a. 记忆分层模型 (Hierarchical Memory Model)

| 路径                      | 层级           | 描述                                              | 权限与生命周期                                       |
| ------------------------- | -------------- | ------------------------------------------------- | ---------------------------------------------------- |
| `.memory/L0_core/`        | **核心记忆**   | 定义 AI 身份、核心指令、价值观。                  | 系统启动时无条件加载，永不卸载、永不修改。           |
| `.memory/L1_declarative/` | **陈述性记忆** | “是什么”的知识，如项目规范、用户偏好、事实数据。  | 按需加载，长期持久化。                               |
| `.memory/L2_procedural/`  | **程序性记忆** | “如何做”的知识，如可复用的工作流、SOP、代码模板。 | 按需加载，长期持久化。                               |
| `.memory/L3_episodic/`    | **情景记忆**   | 已完成任务的完整日志，用于复盘和优化。            | 归档，通常不直接参与新任务。                         |
| `.memory/L4_working/`     | **工作记忆**   | 当前任务的临时上下文。                            | 任务开始时构建，任务执行中动态更新，任务结束后清理。 |
| `.memory/staging/`        | **暂存区**     | 事务性写入 L1/L2 层前的临时存放区。               | 临时。                                               |
| `.memory/.trash/`         | **回收站**     | 安全清理，临时存放待删除文件。                    | 临时，可由 `memory` 模式按策略清理。                 |

#### b. 记忆压缩机制 (Memory Compression Mechanism)

- **摘要优先 (Summary First)**:

  - L1, L2, L3 中的每个记忆 `.yaml` 文件，都在其层级的 `index.json` 中有一个对应的**摘要 (summary)** 条目。
  - **检索流程**: `orchestrator` 首先扫描轻量的 `index.json`，通过摘要快速筛选，命中后再加载重量级的 `.yaml` 文件本体。

- **指针化引用 (Pointer Reference)**:
  - **格式**: `mem://<layer>/<id>#<optional_path_in_yaml>`
  - **用途**: 对于代码块、长文档等冗长内容，在存入 L1/L2 时，会被替换为此指针。
  - **解析**: AI 在工作记忆 (L4) 中遇到指针时，**必须**调用 `memory` 模式的 `resolve_pointer` 工作流来动态获取原始内容。

---

## 2. 核心工作流 (Core Workflows)

### 2.1 阶段 1：任务初始化与认知加载 (Initialization & Cognitive Loading)

1. **前置检查**: 读取 `.memory/memory.lock` 文件，若存在则严格按其内容设置记忆库状态，若不存在则置为 `PAUSED` 并提问。
2. **分层加载**:
   - **L0**: 无条件完全加载。
   - **L1/L2**: 根据任务性质，判断并激活相关层级。
3. **摘要检索**: 优先读取对应层级的 `index.json`，在摘要中快速匹配。
4. **精准加载**: 仅在摘要匹配成功后，才加载完整的 `.yaml` 文件本体。
5. **构建工作记忆 (L4)**: 将加载的 L0 及匹配上的 L1/L2 记忆全部置入 `.memory/L4_working/` 的一个新建 `json` 文件中。

### 2.2 阶段 2：迭代执行与动态学习 (Execution & Dynamic Learning)

- **动态更新工作记忆**: 在执行过程中，任何新发现的关键信息、临时指令或中间结论，都**必须立即写入**当前的工作记忆 (`L4_working`) `json` 文件中。
- **指针解析**: 遇到 `mem://` 指针时，**必须**调用 `memory` 模式的 `resolve_pointer` 工作流动态解析。

### 2.3 阶段 3：复盘、沉淀与清理 (Review, Persist & Cleanup)

1. **复盘提炼**: 任务核心部分完成后，系统性地复盘工作记忆 `json` 文件，提炼有价值、可复用的知识。
2. **强制前置操作**: 在生成记忆卡片前，**必须**先读取 `.memory/README.md` 文件，确保产出严格遵循最新规范。
3. **压缩与持久化**:
   - **提请审批**: **必须**通过 `ask_followup_question` 向用户提请审批“记忆候选卡片”，并建议其应存入的记忆层级 (L1 或 L2)。
   - **事务性流程**: 经批准后，由 `memory` 模式执行事务性压缩持久化流程：
     1. 调用 `summarize` 工作流生成摘要和指针。
     2. 将处理后的 `.yaml` 文件写入 `.memory/staging/`。
     3. 调用 `update_index` 工作流更新目标层级的 `index.json`。
     4. **仅在索引更新成功后**，将 `.yaml` 文件从 `staging` 移到目标层级目录。
     5. 若失败则回滚（删除暂存文件）。
4. **归档**: 将完整的任务记录归档至 `.memory/L3_episodic/`。
5. **清理**: **必须**由 `orchestrator` 模式遵循“受控清理”原则，在整个父任务结束后，调用 `memory` 模式的 `cleanup` 工作流清理 `.memory/L4_working/`。

---

## 3. 模式职责与权限 (Mode Responsibilities & Permissions)

- **`orchestrator` (总指挥)**:

  - **唯一权限**: 拥有对 `.memory/` 目录的**编辑权**。
  - **核心职责**:
    - 负责驱动整个记忆工作流（加载、传递、清理）。
    - 负责调用 `memory` 模式执行具体的、标准化的记忆操作。
    - 负责执行“清理必须受控”原则，在任务结束后发起并管理工作记忆的清理。

- **`memory` (记忆中枢)**:

  - **定位**: 记忆库的结构工程师，提供确定性、原子化的工作流。
  - **核心职责**: 严格按照预设规范，执行 `init`, `cleanup`, `update_index`, `summarize`, `resolve_pointer`, `empty_trash` 等自动化工作流。**不进行决策，只进行操作**。

- **其他模式**:
  - **权限**: 默认**只读** `.memory/` 目录。
  - **核心职责**:
    - 在 `orchestrator` 构建的 L4 工作记忆上下文中执行任务。
    - 主动识别有价值信息，并向 `orchestrator` 提请持久化。

---

## 4. 交互协议 (Interaction Protocols)

### 4.1 沉淀必须提请 (Proactive Persisting)

- **主动识别**: AI 应在任务执行中主动识别有价值、可复用的新信息。
- **附带理由提请**: **必须**通过 `ask_followup_question` 向用户提议存入记忆库，并明确说明理由和建议层级。

### 4.2 清理必须受控 (Controlled Cleanup)

- **清理权限**: **仅** `orchestrator` 模式拥有清理工作记忆的权限。
- **清理时机**: 在父任务完全结束后，由 `orchestrator` 调用 `memory` 模式的 `cleanup` 工作流执行清理，无需二次询问。对于长周期父任务中的子任务，可提请用户选择是否提前清理。
