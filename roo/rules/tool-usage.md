# 工具使用指南

本文档为 AI 系统提供简洁实用的工具选择和应用指南。
如果有合适的工具，可以尝试调用，可以根据结果进行改进，选择使用或不使用。

---

## 工具分类与选择原则

### 工具选择优先级

1. **内建工具优先**：优先使用系统内置工具而非 MCP 服务工具
2. **精确修改优先**：外科手术式的精确修改优于完全重写
3. **批量操作优化**：合并多个操作以提高效率

### 工具使用原则

- **最小化影响**：选择对系统影响最小的工具
- **可逆性**：优先支持撤销的操作
- **性能考虑**：考虑工具执行效率和资源消耗

---

## 工具详解

### 🔍 探索与分析

_原则：先观察，后行动。_

- **[`list_files`]** - 浏览项目结构，支持递归

  - 用途：了解项目组织结构，快速定位文件
  - 最佳实践：首次接触项目时使用，递归模式可查看完整结构

- **[`read_file`]** - 读取文件内容（最多 5 个）

  - 用途：批量读取多个文件内容，提高效率
  - 限制：单次最多读取 5 个文件

- **[`list_code_definition_names`]** - 获取代码定义概览

  - 用途：快速了解代码库的 API 和结构
  - 适用场景：分析陌生代码库时

- **[`search_files`]** - 正则搜索文件内容
  - 用途：在项目中搜索特定代码模式或文本
  - 技巧：使用精确的正则表达式，避免过于宽泛的匹配

### ✏️ 文件编辑

_原则：外科手术式的精确修改优于完全重写。_

- **[`apply_diff`]** - 精确修改代码段（优先使用）

  - 用途：对现有文件进行精确的、定位的修改
  - 优势：最小化意外修改的风险

- **[`insert_content`]** - 在指定行插入内容

  - 用途：在文件特定位置添加新内容
  - 适用：添加导入语句、函数定义等

- **[`search_and_replace`]** - 批量查找替换

  - 用途：全局替换特定文本或模式
  - 注意：谨慎使用，确保替换范围准确

- **[`write_to_file`]** - 创建新文件或完全重写
  - 用途：创建新文件或需要完全重写现有文件
  - 警告：会覆盖整个文件内容

#### 文件操作细则

- **优先原则:**

  - 优先使用 `Tools` 部分提供的工具方法而非 mcp 服务提供的工具方法
  - 优先使用编辑的方式修改文件而非 `write_to_file`

- **操作顺序:**

  - **编辑/修改:** `apply_diff` > `search_and_replace` > `edit_file` > `write_to_file`
  - **添加内容:** `insert_content` > `write_append` > `write_to_file`
  - **覆盖内容 (确保完整性):** `write_to_file`

- **路径与分片:**
  - 确保使用绝对路径来替代相对路径
  - 由于资源的限制，处理文件时会对文件按照 500 行为单位进行分片处理（如：1-500, 501-1000）
  - 每次分片处理完成后，重新加载文件以确保后续分片处理的准确性
  - 确保单次处理文件的总行数不超过 500 行

### 💬 交互决策

_原则：将复杂任务分解，并始终保持用户的主导权。_

- **[`ask_followup_question`]** - 请求用户决策（提供选项）

  - 用途：在需要用户选择或确认时使用
  - 最佳实践：提供清晰、具体的选项

- **[`update_todo_list`]** - **追加或更新**任务清单，而非完全覆盖

  - 用途：动态管理任务列表，跟踪进度
  - 注意：此工具用于追加或更新，不是完全替换

- **[`new_task`]** - 委派给专业模式
  - 用途：将任务委派给更专业的模式处理
  - 参考：详见 [`task.md`](task.md) 中的委派规范

### ⚙️ 系统操作

_原则：将执行与交付作为任务的最后环节。_

- **[`execute_command`]** - 执行命令行操作

  - 用途：执行系统命令、运行脚本、安装依赖等
  - 注意：每个命令在新的终端实例中运行

- **[`attempt_completion`]** - 完成任务交付
  - 用途：标记任务完成并提交最终结果
  - 时机：所有工作完成后使用

#### 命令行操作细则

- **组合命令:** 当进行 command 操作时，不得使用 `&&` 符号进行命令组合
- **决策建议:** 在执行前，系统性地收集并分析每个选项的优缺点及其他相关因素
- **决策优化:**
  - 前置重要决策，避免返工
  - 批量收集信息后统一决策
- **工具链优化:**
  - 优先使用内建工具而非 `execute_command`
  - 避免重复读取未修改的文件

### 🌐 网页获取

_原则：使用最合适的工具，并确保结果与预期一致。_

- **[`fetch`]** - 获取网页内容
- **[`fetch_json`]** - 获取 JSON 数据
- **[`fetch_html`]** - 获取网页内容
- **[`fetch_xml`]** - 获取 XML 数据
- **[`fetch_markdown`]** - 获取 Markdown 数据
- **[`execute_command`]**
  - **`curl`** - 使用 curl 命令行工具执行 HTTP 请求
  - **`wget`** - 使用 wget 命令行工具执行 HTTP 请求

---

## 性能优化策略

### 批量操作

- **文件读取**: 合并多个 `read_file` 请求（最多 5 个）
- **代码修改**: 单个 `apply_diff` 处理多个修改
- **命令执行**: 避免不必要的命令链，使用脚本文件

### 缓存策略

- 避免重复读取未修改的文件
- 缓存频繁访问的配置信息
- 合理使用文件分片处理大文件

### 错误处理

- 使用适当的工具处理特定错误类型
- 记录错误日志以便调试
- 提供清晰的错误信息和恢复建议

---

## 异常处理指南

### 快速参考表

| 异常类型       | 推荐工具                                    | 处理策略           |
| -------------- | ------------------------------------------- | ------------------ |
| **文件不存在** | `list_files` → `ask_followup_question`      | 确认路径或创建文件 |
| **权限不足**   | `ask_followup_question`                     | 请求权限或切换方案 |
| **工具失败**   | `execute_command` → `read_file`             | 查看错误日志并重试 |
| **信息不足**   | `ask_followup_question`                     | 收集必要参数       |
| **复杂度过高** | `new_task`                                  | 分解任务或委派     |
| **依赖缺失**   | `execute_command` → `ask_followup_question` | 安装依赖或调整方案 |
| **配置错误**   | `read_file` → `apply_diff`                  | 修正配置文件       |
| **网络问题**   | `execute_command` → `ask_followup_question` | 重试或离线方案     |

### 标准处理流程

1. **识别异常**

   - 触发：工具执行失败或返回错误
   - 操作：分析错误类型和原因

2. **选择处理策略**

   - 可自动修复 → 执行修复工具
   - 需要信息 → `ask_followup_question`
   - 超出能力 → `new_task` 委派

3. **执行恢复**
   - 执行：根据策略使用相应工具
   - 验证：确认恢复成功
   - 记录：`update_todo_list` 更新状态

---

## 最佳实践总结

1. **工具选择**

   - 根据任务性质选择最合适的工具
   - 考虑性能、安全性和可维护性

2. **操作顺序**

   - 先探索，后修改
   - 先备份，后操作
   - 先测试，后提交

3. **错误预防**

   - 验证输入参数
   - 检查文件存在性
   - 确认操作权限

4. **效率优化**
   - 批量处理相似操作
   - 避免重复计算
   - 合理使用缓存
