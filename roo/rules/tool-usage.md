# 工具使用指南

AI 系统工具选择和应用指南。

## 工具选择原则

| 优先级 | 原则         | 说明                                   |
| ------ | ------------ | -------------------------------------- |
| 1      | 内建工具优先 | 优先使用系统内置工具而非 MCP 服务工具  |
| 2      | 精确修改优先 | 外科手术式精确修改优于完全重写         |
| 3      | 批量操作优化 | 合并多个操作以提高效率                 |
| 4      | 上下文相关   | 基于任务选择最相关工具，避免过度工程化 |

## 工具使用原则

- **最小化影响**：选择对系统影响最小的工具
- **可逆性**：优先支持撤销的操作
- **性能考虑**：考虑执行效率和资源消耗
- **模式适配**：根据当前模式选择合适工具
- **简洁性**：优先选择简单直接的解决方案

## 工具详解

### 🔍 探索与分析

原则：先观察，后行动。

| 工具                         | 用途                          | 限制/技巧                  |
| ---------------------------- | ----------------------------- | -------------------------- |
| `list_files`                 | 浏览项目结构，支持递归        | 首次接触项目时使用         |
| `read_file`                  | 批量读取文件内容（最多 5 个） | 单次最多 5 个文件          |
| `list_code_definition_names` | 获取代码定义概览              | 分析陌生代码库时使用       |
| `search_files`               | 正则搜索文件内容              | 使用精确正则，避免宽泛匹配 |

### ✏️ 文件编辑

原则：精确修改优于完全重写。

| 工具                 | 用途                   | 注意事项               |
| -------------------- | ---------------------- | ---------------------- |
| `apply_diff`         | 精确修改代码段（优先） | 最小化意外修改风险     |
| `insert_content`     | 在指定行插入内容       | 适合添加导入、函数定义 |
| `search_and_replace` | 批量查找替换           | 谨慎使用，确保范围准确 |
| `write_to_file`      | 创建新文件或完全重写   | 会覆盖整个文件内容     |

#### 文件操作优先级

| 操作类型  | 优先级顺序                                                          |
| --------- | ------------------------------------------------------------------- |
| 编辑/修改 | `apply_diff` > `search_and_replace` > `edit_file` > `write_to_file` |
| 添加内容  | `insert_content` > `write_append` > `write_to_file`                 |
| 覆盖内容  | `write_to_file`                                                     |

#### 文件处理规则

- 使用绝对路径而非相对路径
- 500 行为单位分片处理大文件
- 每次分片处理后重新加载文件
- 单次处理不超过 500 行

### 💬 交互决策

原则：分解任务，保持用户主导权。

| 工具                    | 用途           | 特点                     |
| ----------------------- | -------------- | ------------------------ |
| `ask_followup_question` | 请求用户决策   | 提供清晰选项             |
| `update_todo_list`      | 更新任务清单   | 追加或更新，非完全覆盖   |
| `new_task`              | 委派给专业模式 | 详见 `task.md`](task.md) |

#### ask_followup_question 使用场景

| 场景         | 需求             | 操作                                   |
| ------------ | ---------------- | -------------------------------------- |
| 任务拆解确认 | 展示完整执行计划 | 流程图、任务清单、改进建议             |
| 技术方案选择 | 多方案对比       | 优缺点对比、推荐理由、风险应对         |
| 需求澄清     | 模糊需求         | 列出问题、提供选项、建议默认方案       |
| 边界确认     | 防止蔓延         | 明确边界、列出范围外内容、建议扩展方向 |

#### 模式选择策略

| 因素       | 考虑点                       |
| ---------- | ---------------------------- |
| 专业匹配度 | 根据任务类型选择最专业模式   |
| 模型成本   | 常规任务用成本效益高的模型   |
| 上下文传递 | 最小化模式切换时的上下文丢失 |
| 任务依赖   | 考虑任务间依赖和执行顺序     |

### ⚙️ 系统操作

原则：执行与交付作为最后环节。

| 工具                 | 用途           | 注意                     |
| -------------------- | -------------- | ------------------------ |
| `execute_command`    | 执行命令行操作 | 每个命令在新终端实例运行 |
| `attempt_completion` | 完成任务交付   | 所有工作完成后使用       |

#### 命令行操作规则

- 禁止使用 `&&` 组合命令
- 执行前分析选项优缺点
- 前置重要决策，避免返工
- 优先使用内建工具

## 性能优化

### 批量操作

- 合并多个 `read_file` 请求（最多 5 个）
- 单个 `apply_diff` 处理多个修改
- 使用脚本文件避免命令链

### 缓存策略

- 避免重复读取未修改文件
- 缓存频繁访问的配置信息
- 合理使用文件分片处理大文件

### 错误处理

- 使用适当工具处理特定错误
- 记录错误日志
- 提供清晰错误信息和恢复建议

## 异常处理指南

### 快速参考表

| 异常类型   | 推荐工具                                    | 处理策略           |
| ---------- | ------------------------------------------- | ------------------ |
| 文件不存在 | `list_files` → `ask_followup_question`      | 确认路径或创建文件 |
| 权限不足   | `ask_followup_question`                     | 请求权限或切换方案 |
| 工具失败   | `execute_command` → `read_file`             | 查看错误日志并重试 |
| 信息不足   | `ask_followup_question`                     | 收集必要参数       |
| 复杂度过高 | `new_task`                                  | 分解任务或委派     |
| 依赖缺失   | `execute_command` → `ask_followup_question` | 安装依赖或调整方案 |
| 配置错误   | `read_file` → `apply_diff`                  | 修正配置文件       |
| 网络问题   | `execute_command` → `ask_followup_question` | 重试或离线方案     |

### 标准处理流程

1. **识别异常**

   - 触发：工具执行失败
   - 操作：分析错误类型和原因

2. **选择策略**

   - 可自动修复 → 执行修复工具
   - 需要信息 → `ask_followup_question`
   - 超出能力 → `new_task` 委派

3. **执行恢复**
   - 执行：使用相应工具
   - 验证：确认恢复成功
   - 记录：`update_todo_list` 更新状态

## 最佳实践

1. **工具选择**

   - 根据任务性质选择最合适工具
   - 考虑性能、安全性、可维护性
   - 避免过度工程化

2. **操作顺序**

   - 先探索，后修改
   - 先备份，后操作
   - 先测试，后提交

3. **错误预防**

   - 验证输入参数
   - 检查文件存在性
   - 确认操作权限

4. **效率优化**

   - 批量处理相似操作
   - 避免重复计算
   - 合理使用缓存

5. **简洁性原则**
   - 优先选择简单直接方案
   - 避免不必要的复杂性
   - 最小化工具调用次数
