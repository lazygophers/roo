---
name: task
title: 任务管理指南
description: "AI系统任务分解、评估与执行的核心规范"
category: rule
priority: critical
tags: [任务管理, 模式协作, 工作流程]
---

# 任务管理指南

## 核心理念

- **简洁明了**: 描述清晰，避免冗余
- **精准匹配**: 信息高度聚焦，仅提供任务相关上下文
- **模式驱动**: 根据任务性质选择最适合的专业模式
- **价值导向**: 每个任务明确价值点和预期产出

## 任务层级

### 两层架构

```
调度层 (orchestrator)
    ↓ 任务分解与委派
执行层 (各专业模式)
```

### 层级职责

| 层级       | 职责                         | 模式           |
| ---------- | ---------------------------- | -------------- |
| **调度层** | 任务分解、依赖管理、结果汇总 | `orchestrator` |
| **执行层** | 专业实现、原子操作、直接交付 | 各专业模式     |

### 任务流向

1. **复杂任务进入调度层**

   - `orchestrator` 接收并分析
   - 分解为可执行的子任务
   - 委派给对应的专业模式

2. **子任务进入执行层**
   - 各模式按专业领域执行
   - 完成后返回结果
   - 由 `orchestrator` 汇总

## 模式协作机制

### 模式选择指南

详细模式职责和选择标准请参考 new_task.md#模式选择指南

### 协作流程

#### 标准流程

1. **任务接收** → `orchestrator`

   - 分析任务复杂度
   - 识别所需专业领域
   - 制定任务分解策略

2. **任务分解** → `orchestrator`

   - 创建子任务清单
   - 确定任务依赖关系
   - 分配执行模式

3. **专业执行** → 各专业模式

   - 按专业领域执行
   - 必要时进行模式间协作
   - 保持上下文传递

4. **结果汇总** → `orchestrator`
   - 收集各子任务结果
   - 验证整体完成度
   - 准备最终交付

#### 典型场景

**新功能开发**:

```
orchestrator → architect → code → debug → doc-writer
     ↓           ↓        ↓       ↓          ↓
  任务分解 → 架构设计 → 代码实现 → 测试调试 → 文档编写
```

**系统重构**:

```
orchestrator → project-research → architect → code → giter
     ↓                ↓              ↓        ↓        ↓
  任务分解 → 代码库分析 → 重构方案设计 → 重构实施 → 版本管理
```

## 工作流程

### 执行原则

1. **模式切换**: 禁止使用 `switch_mode`，通过 `new_task` 转换
2. **任务粒度**: 非 orchestrator 模式下，任务必须原子化
3. **决策确认**: L1 级决策需通过 `ask_followup_question` 确认
4. **信息呈现**: 使用流程图、清单、表格等可视化方式
5. **模式专业化**: 严格专业分工，超出能力的任务必须委派
6. **上下文精简**: 仅传递任务相关上下文，避免过载

### 优化策略

#### 批量操作

- 单个 `apply_diff` 处理多个修改
- 合并 `read_file` 请求（最多 5 个）

#### 性能优化

- 合并相似操作，减少工具调用
- 缓存频繁访问的信息
- 使用脚本替代命令链

#### 质量保证

- 执行前验证前置条件
- 关键节点更新任务状态
- 保持输出一致性

### 上下文管理

#### 传递原则

- 使用 `task_id_list` 追踪任务来源
- 在 `metadata.dependencies` 中声明依赖
- 保持信息精简完整

#### 信息过滤

- 仅传递任务直接相关信息
- 避免复制整个历史上下文
- 使用引用而非嵌入大型内容

## 任务清单管理

### 动态更新原则

- **及时性**: 任务状态变更后立即更新
- **准确性**: 确保清单与实际执行一致
- **完整性**: 包含所有相关任务
- **可追溯性**: 保留状态变更历史

### 执行反馈机制

1. **成功完成**

   - 更新任务状态为已完成
   - 记录实际用时和资源消耗
   - 解除依赖任务的阻塞

2. **部分完成**

   - 拆分未完成部分为新任务
   - 更新完成百分比
   - 调整依赖关系

3. **执行失败**

   - 记录失败原因和解决方案
   - 创建重试任务或替代方案
   - 通知相关方

4. **需求变更**
   - 创建新任务反映变更
   - 标记原任务为废弃
   - 建立新旧任务关联

### 更新操作规范

- **增量更新**: 仅变更需要修改的任务项
- **保留历史**: 不删除已完成或失败的记录
- **状态流转**: 遵循 pending → in_progress → completed
- **批量操作**: 单一操作更新多个相关任务

### 清单同步策略

- **实时广播**: 任务状态变更立即通知相关模式
- **版本控制**: 为每次更新创建快照
- **冲突解决**: 建立更新优先级机制
- **一致性检查**: 定期验证清单一致性

## 最佳实践

### 任务设计

- ✅ 任务描述清晰、具体、可衡量
- ✅ 明确定义验收标准
- ✅ 合理设置任务边界
- ✅ 考虑任务间依赖关系

### 执行策略

- ✅ 优先处理关键路径任务
- ✅ 并行执行无依赖的任务
- ✅ 及时识别和处理阻塞
- ✅ 保持与用户持续沟通

### 协作优化

- ✅ 明确各模式职责边界
- ✅ 建立清晰的信息传递机制
- ✅ 定期同步任务进度
- ✅ 记录关键决策和变更

### 任务清单管理

- ✅ 及时更新任务状态
- ✅ 根据执行结果动态调整
- ✅ 使用更新而非覆盖
- ✅ 保持清单可读性
- ✅ 建立反馈循环
