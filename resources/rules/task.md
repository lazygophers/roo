---
name: task
title: 任务管理指南
description: "AI系统任务分解、评估与执行的核心规范"
category: rule
priority: critical
tags: [任务管理, 模式协作, 工作流程]
---

# 任务管理指南

## 核心理念

- **简洁明了**: 描述清晰，避免冗余
- **精准匹配**: 信息高度聚焦，仅提供任务相关上下文
- **模式驱动**: 根据任务性质选择最适合的专业模式
- **价值导向**: 每个任务明确价值点和预期产出

## 任务层级

### 两层架构

```
调度层 (orchestrator)
    ↓ 任务分解与委派
执行层 (各专业模式)
```

### 层级职责

| 层级       | 职责                         | 模式           |
| ---------- | ---------------------------- | -------------- |
| **调度层** | 任务分解、依赖管理、结果汇总 | `orchestrator` |
| **执行层** | 专业实现、原子操作、直接交付 | 各专业模式     |

### 任务流向

1. **复杂任务进入调度层**

   - `orchestrator` 接收并分析
   - 分解为可执行的子任务
   - 委派给对应的专业模式

2. **子任务进入执行层**
   - 各模式按专业领域执行
   - 完成后返回结果
   - 由 `orchestrator` 汇总

## 模式协作机制

### 模式选择指南

详细模式职责和选择标准请参考 new_task.md#模式选择指南

### 协作流程

#### 标准流程

1. **任务接收** → `orchestrator`

   - 分析任务复杂度
   - 识别所需专业领域
   - 制定任务分解策略

2. **任务分解** → `orchestrator`

   - 创建子任务清单
   - 确定任务依赖关系
   - 分配执行模式

3. **专业执行** → 各专业模式

   - 按专业领域执行
   - 必要时进行模式间协作
   - 保持上下文传递

4. **结果汇总** → `orchestrator`
   - 收集各子任务结果
   - 验证整体完成度
   - 准备最终交付

#### 典型场景

**新功能开发**:

```
orchestrator → architect → code → debug → doc-writer
     ↓           ↓        ↓       ↓          ↓
  任务分解 → 架构设计 → 代码实现 → 测试调试 → 文档编写
```

**系统重构**:

```
orchestrator → project-research → architect → code → giter
     ↓                ↓              ↓        ↓        ↓
  任务分解 → 代码库分析 → 重构方案设计 → 重构实施 → 版本管理
```

## 工作流程

### 执行原则

1. **模式切换**: 禁止使用 `switch_mode`，通过 `new_task` 转换
2. **任务粒度**: 非 orchestrator 模式下，任务必须原子化
3. **决策确认**: L1 级决策需通过 `ask_followup_question` 确认
4. **信息呈现**: 使用流程图、清单、表格等可视化方式
5. **模式专业化**: 严格专业分工，超出能力的任务必须委派
6. **上下文精简**: 仅传递任务相关上下文，避免过载

### 优化策略

| 类型 | 方法 | 要点 |
|------|------|------|
| **批量操作** | 合并请求 | `apply_diff` 处理多个修改，`read_file` 最多5个 |
| **性能优化** | 减少调用 | 缓存频繁访问信息，使用脚本替代命令链 |
| **质量保证** | 验证机制 | 执行前验证前置条件，关键节点更新状态 |
| **上下文管理** | 精简传递 | 仅传递任务相关信息，使用 `task_id_list` 追踪来源 |

## 任务清单管理

### 动态更新原则

| 原则 | 要求 | 操作规范 |
|------|------|----------|
| **及时性** | 状态变更后立即更新 | 增量更新，遵循 pending → in_progress → completed |
| **准确性** | 清单与实际执行一致 | 保留历史记录，不删除已完成或失败任务 |
| **完整性** | 包含所有相关任务 | 批量操作，实时广播状态变更 |
| **可追溯性** | 保留状态变更历史 | 版本控制，为每次更新创建快照 |

### 执行反馈机制

| 状态 | 处理方式 | 关键操作 |
|------|----------|----------|
| **成功完成** | 更新状态为已完成 | 记录实际用时，解除依赖任务阻塞 |
| **部分完成** | 拆分未完成部分 | 更新完成百分比，调整依赖关系 |
| **执行失败** | 记录失败原因 | 创建重试任务，通知相关方 |
| **需求变更** | 创建新任务反映变更 | 标记原任务废弃，建立新旧关联 |

## 最佳实践

| 类别 | 核心要点 | 关键操作 |
|------|----------|----------|
| **任务设计** | 清晰、具体、可衡量 | 明确验收标准，设置任务边界，考虑依赖关系 |
| **执行策略** | 关键路径优先 | 并行执行无依赖任务，及时处理阻塞，持续沟通 |
| **协作优化** | 明确职责边界 | 清晰信息传递，定期进度同步，记录关键决策 |
| **清单管理** | 及时更新状态 | 动态调整，增量更新，保持可读性，建立反馈循环 |


## 多层级任务管理

### 结构设计

**核心原则**：层级深度≤4层，使用点号编号（如1.1.1），父子任务依赖明确。

**编号格式**：
```
1. [ ] 一级任务
   1.1. [ ] 二级任务
      1.1.1. [ ] 三级任务
```

**状态管理**：
- 父任务状态根据子任务自动计算
- 状态流转：pending → in_progress → completed
- 支持增量更新和批量操作

### 可视化格式

| 格式类型 | 适用场景 | 示例 |
|----------|----------|------|
| 缩进列表 | 层级展示 | `├── 1.1. [x] 子任务` |
| 表格格式 | 详细信息 | 任务ID、状态、进度、负责人 |
| 树状图 | 依赖关系 | Mermaid 流程图 |
| 看板格式 | 状态管理 | 待办/进行中/已完成 |

### 执行原则

**设计要求**：
- 叶子任务1-3天内完成
- 自顶向下分解
- 明确任务依赖关系
- 支持动态调整

**管理规范**：
- 优先处理关键路径任务
- 并行执行无依赖任务
- 及时更新任务状态
- 定期回顾调整结构